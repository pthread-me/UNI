\documentclass[cspaper]{IEEEtran}

% Set the margins of the page.
\usepackage[a4paper, total={6.5in, 9in}]{geometry}

% A bunch of math packages.
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{mathtools}

\usepackage{graphicx} 		% Insert images
\usepackage{changepage}
\usepackage{color}				% COLORS!
\usepackage[shortlabels]{enumitem}			% More itemize types such as \alph*
\usepackage{listings}			% Used for code-blocks in latex.
\usepackage{hyperref}

% Create links when using ref and table of contents.
\hypersetup{colorlinks=true, linkcolor=black}

% Replace the indents for paragraphs with empty lines.
%\usepackage[parfill]{parskip}

\usepackage[myheadings]{fancyhdr}
\usepackage{titleref}
\makeatletter
\newcommand*{\currentname}{\TR@currentTitle}
\makeatother

% Number equations with reference to sub sections.
\numberwithin{equation}{subsection}

\definecolor{lightgray}{RGB}{220, 220, 220}

%frame=single,
%basicstyle=\fontsize{10pt}{15pt}\selectfont,
%stepnumber=1,
%backgroundcolor=\color{backcolour},   
%commentstyle=\color{codegreen},
%keywordstyle=\color{magenta},
%numberstyle=\tiny\color{codegray},
%stringstyle=\color{codepurple},
\lstdefinestyle{mystyle}{
	%basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
		literate={<-}{$\leftarrow$}{2} {\\infty}{$\infty$}{1} {\\equiv}{$\equiv$}{1}
		{\\IntegerModm}{$(\mathbb{Z}/m\mathbb{Z})$}{7} {\\in}{$\in$}{1} {\\varphim}{$\varphi(m)$}{5}
		{\\integers}{$\mathcal{Z}$}{1} {\\IntegerModn}{$(\mathbb{Z}/n\mathbb{Z})$}{7},
		backgroundcolor=\color{lightgray},
		frame=single,
		framesep=0pt,
		xleftmargin=20pt,
		framexleftmargin=0pt,
		framexrightmargin=-30pt,
		framextopmargin=2pt,
		framexbottommargin=2pt
}

% Set some style rules for code-blocks
\lstset{style=mystyle}


%increases table padding
\def\arraystretch{1.5}



\title{Title Placeholder}
\author{Anas Alhadi\\B00895875}


\begin{document}

	\maketitle
	
	\fancyhead[L]{\text{B00895875}}
	\fancyhead[R]{\text{Anas Alhadi}}
	\thispagestyle{fancy}


\par{
		\emph{Abstract} Static Context Header Compression (SCHC) is an adaptation layer
		capable of achieving large compression ratios on upper layer protocol headers (ie: IPv6, CoAP) by exploiting the presistent and predictable nature of 
		IoT networks to make use of predefined static compression rules that act as a blueprints for the 
		expected network traffic in which a sender can avoid transmitting the entire packet when a matching blueprint is present and instead sends a pointer to the rule. The 
		afformentioned properities that SCHC builds on however makes it unideal for use in mobile networks in which the metadata we want to compress is variable.
		We look into the prospects of introducing dynamic updating of rules by evaluating the performance of scoring/weight assignment heuristics on
		network traffic to predict rules with improved packet coverage. Our results show that in the presence of reasonable assumptions an overall 
		improvement on the average header size is possible. 
	}

\section{Introduction}
	\par{
			The recent boom of IoT based networks facilitated the need for a shared networking layer to enable seemless 
			communication between various types of devices regardless of their underlying communication medium and protocols. As such IPv6 
			has been widley adopted to play that role \textcolor{red}{cite IoV paper}. Yet, this in itself introduced a new set of challenges, specifically for long-distance low-power
			communications (ie LPWAN networks) that have physical restrictions on the size of the maximum transmission unit (MTU) of which the size of an IPv6 header often exceeds. Moreover, the additional 
			bloat introduced by the IP metadata result in longer time-on-air during message transmission thus increasing power consumption \textcolor{red}{cite schc impact paper}.
		}
		\par{
			A solution to the aformentioned was introduced by the LPWAN working group at the IETF in the form of the SCHC protocol
			with mechanisms for compression and fragmentation\textcolor{red}{cite rfc 8724}. SCHC has recieved wide adoption, with the LoRa Allience choosing
			it as the IPv6 adaptation layer for LoRa based communications, as well as the emergence of a considerable range
			of studies examining it's use in mobility centered IoT networks, such as that of the Internet of Vehicles via IPv6 over LoRa \textcolor{red}{cite IoV paper}, 
			and in Direct-to-satellite IoT networks (DtS-IoT)\textcolor{red}{cite the dts-iot paper}
		}
		\par{We notice however that most of the testing done on SCHC in mobile networks required manual configuration, 
		leaving an unexamined hole in the literature regarding the feasibility of implementing
		SCHC in mobile applications in which the most impactful metadata fields become uncompressable via SCHC's framework (ie: the source and destination IPv6 addresses). 

		This study aims to evaluate the use of weight assignment hueristics on network
		traffic to construct new SCHC rules based on the state of the end-to-end communication, thus providing a mechanism for dynamic rule updating.
	}
	\par{
		This work is organized as follows. Chapter 2 is an overview of the SCHC framework. Chapter 3 describes the short comings of SCHC in 
		mobile networks. Chapter 4 describes the packet scoring algorithm and the test bed used. Chapter 5 presents and discusses the results.
	}

\section{Network Architecture}
	\par{
		Because SCHC is built with LPWAN in mind \textcolor{red}{cite rfc 8873}, there is an implicit assumption that the communication is between
		a low-power low-compute IoT device (DEV) and a more powerfull network gateway (Core).
	}
\section{SCHC Compression  Background}
	

	\par{
		SCHC uses a lossless context based compression mechanism, that is, it makes use of previous knowledge
		about a given communication to omit repeated parts of a packet's metadata. Though it
		differs from other context based compression protocols in the derivation of said contexts,
		in which contexts are acquired in a purely offline and manual manner, relying on the network admin's assumed
		pre-existing knowledge on the state of the communication between two endpoints to predefine the rules needed.
		This assumption is not only safe, given the stable and simple nature of IoT applications with devices often running a single application, but
		also plays an important role in bypassing the need for synchronization messages. To put it into perspective, the minimum size of the metadata in a 
		COAP/UDP/IPv6 network stack is $\approx 60 \ bytes$ per packet, while a single SCHC context represented in YANG format and compressed via CBOR 
		(which is the defacto-standard binary representation \textcolor{red}{cite CBOR}) results in 
		a message of $\approx 400 \ bytes$, this in itself makes flow based context synchronization (similar to that used in the ROHC protocol) unideal as we will need to compress
		7 IPv6 packets per flow before seeing a net gain, which is unrealistic given that minimizing the time-on-air of communications is 
		the main reason we perform compression in the first place.
	}
	
	\vspace{1em}
\subsection{Context Structure}
	\par{
		The initial step in compression is to classify packets based on stored contexts at the sender. 
		To best understand the classification process, it is benificial to cover the 
		hierarchical structure of SCHC contexts.
	}

	\vspace{1em}
	\subsubsection{Context}
	
	\begin{equation}\notag
		C \ = \ (CID, \ R)
	\end{equation}

	Each context is represented as a pair, in which:
	\begin{itemize}
		\item \textbf{CID} is a unique identifier for the DEV relative to all other devices connected to the Core. 
		\item \textbf{R} is a set of Rules.
	\end{itemize} 

	\vspace{1em}
	\subsubsection{Rules}
	
	\par{
	Similar to contexts, each rule $r \in R$ is represented as a pair, in which:
	}
	\begin{equation}\notag
		r = (RID, \ F)	
	\end{equation}
	\begin{itemize}
		\item \textbf{RID} is a unique identifier for the rule, relative to all rules in the Core's network.
		\item \textbf{F} is a set of Fields.
	\end{itemize}

	\vspace{1em}
	\subsubsection{Fields}
	Finally, each Field $f \in F$ is represented as a 7-tuple in which:
	\begin{equation}\notag	
		f = (\ FID, \ FL, \ FP, \ DI, \ TV, \ MO, \ ACT \ )
	\end{equation}

	\begin{itemize}
		\item \textbf{FID} is a Field identifier, used to identify the specific header field\footnote{field here refers to a field in 
			a network header, while Field is that in the context of SCHC rules.} that the SCHC Field is representing (ie: UDP source port, IPv6 destination address)


		\item \textbf{FL}
			is the Field's length representing the size, in bits, of the original header field that the Field is representing (ie: 128 for an IPv6 source address)
		\item \textbf{FP:} 
			The Field's position, used to distinguish between header fields that can have multiple instances in a single header. (ie: Uri-Path field in CoAP headers). 

		\item \textbf{DI:} 
			 A Direction Indicator, can take one of 3 values \{Up, Dw, Bi\}. Indicating whether the field can be applied to a packet based on the direction of traffic
			in relation to the DEV and the Core. In which ``Up" refers to traffic from the device to the Core, ``Dw" is downlink traffic moving from
			the Core to the device, while ``Bi" applies the field to packets traveling in both directions.

	\item \textbf{TV:}
			The Target Value that the header field is compared against. Can be a scalar value or a vector depending on the MO used. With the types that the 
			TV can take being dictated by the SCHC implementation.

	\item \textbf{MO:}
			Matching Operator, this dictates the comparision function to apply on the header's field against the target value. SCHC defines 4 functions:
			\begin{adjustwidth}{1em}{0em}
			\begin{itemize}
				\item  \textbf{Equal:} 
						a simple equality comparision, requires target value to be a scalar.
					\item \textbf{Ignore:}
						always returns true.
					\item \textbf{MSB(x):} 
						compares the most significat $x$ bits of the header's field against a scalar target value.
					\item \textbf{Match-mapping:}
					returns true if the header's field matches any of the Target Values, requires TV to be a vector.
			\end{itemize}	
			\end{adjustwidth}	
			

		\item \textbf{ACT:}
				Defines the compression/decompression action to be taken when the matching operation passes. SCHC defines 7 such actions:
				
			\begin{adjustwidth}{1em}{0em}
				\begin{itemize}
					\item \textbf{not-sent:} Compression omits the field value, with the stored target value being used at decompression. Used with the equal MO
					\item \textbf{value-sent:} Compression keeps the field as is,  with the recieved value being used at decompression.
					\item \textbf{mapping-sent:} Compression outputs the index of the Target Value in the TV vector. Decompression uses the element at said index. Used with the 
						match-mapping MO
					\item \textbf{LSB:} Compression omits the $x$ most significant bits, outputting the remaining $FL-x$ least significant bits. At decompression the $x$ MSB stored
						at the target value are concatenated with the recieved LSB. Requires the MO to be set to MSB(x) 
					
					\item \textbf{App IID:} omits the 64 least significant bits from the Core's IPv6 address at compression, and use the Core's MAC address when decompressing.
					\item \textbf{Dev IID:} omits the 64 least significant bits from the DEV's IPv6 address at compression, and use the DEV's MAC address when decompressing.

				\end{itemize}
			\end{adjustwidth}
	\end{itemize}

	\subsection{Packet Classification}
	Packet classification refers to the process of determining the rule with which a packet header is to be
	compressed by, the process only occurs at the sender. The first step is to determine the flow direction of the packet, in the context 
	of SCHC this can either be:
	\begin{itemize}
		\item \textbf{Uplink:} DEV to Core.
		\item \textbf{Downlink:} Core to DEV.
	\end{itemize}

	\vspace{1em}
	Uplink traffic is the trivial case since DEV only stores a single context. On the otherhand, to compress Downlink traffic, the Core must search
	for the context with the CID corresponding to the desired DEV. SCHC puts no restriction on what determines the CID value, though it provides 
	the option to use the DEV's MAC address (or any Layer 2 address) as a CID. 

	\vspace{1em}
	Once the compressor decides on a context\\ $C = (CID, R) | CID = DEV$

\section{Conclusion}


\end{document}
